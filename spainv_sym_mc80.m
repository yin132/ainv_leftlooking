function [M,D] = spainv_sym_mc80(A,order,droptol,droptol_type)
%
% This subroutine gives an approximate inverse factorization of a real
% symmetric matrix such that M'*A*M = D, in left-looking style. The input 
% matrix A has been preprocessed by HSL's MC80, and we are not doing any 
% pivoting in this subrouine. Instead, we simply follow the partition of A 
% generated by mc80, passed in here through the input `order'. 
% order(dd) > 0 means the dd-th row/column of A is partitioned as a single 
% row/column (1x1 pivot should be used), whereas order(dd) < 0 means the 
% dd-th and (dd+1)-st rows/colums are partitioned together (2x2 pivot)
%

normA = norm(A,1);
n = length(A);
normAFro = norm(A,'fro');
% initial unit upper triangular M and block diagonal D (stored as a tri-
% diagonal and hence can be constructed explicitly from the main diagonal
% and subdiagonal, due to the real symmetry of A)
M = speye(n,n);
D = sparse(n,n);
invD = sparse(n,n);

droptol_max = 5e-1;

pvttypesum = zeros(3,1);
small_sv_D = realmax;
large_sv_D = realmin;
progress = zeros(10,1);

dd = 1;
while dd <= n
    if order(dd) > 0,   s = 1;
    else,               s = 2;      
    end
    prj_pvt_cols = ((A*M(:,dd:dd-1+s))'*M(:,1:dd-1))';
    M(:,dd:dd-1+s) = M(:,dd:dd-1+s) - M(:,1:dd-1)*(invD(1:dd-1,1:dd-1)*prj_pvt_cols);

    pvt_idx = dd:dd-1+s;
    M_pvtcols = M(:,pvt_idx);
        
    % dropping small elements in the pivot columns, one column at a time
    for jj = 1 : s
        % assemble all nonzero elements in the current pivot column
        [nzidx,~,tmpv] = find(M_pvtcols(1:dd-2+jj,jj));
        if ~isempty(nzidx)
            if strcmpi(droptol_type,'relative')
                % sort the nonzero elements in the current pivot column,
                % and drop the smallest ones whose sum is no greater than
                % droptol times the total sum of all nonzero elements;
                % (note that we could sum up the elements themselves or
                % of their squares)
                [ordtmpv,ordix] = sort(conj(tmpv).*tmpv);   %sort(abs(tmpv));  %
                cumsum_ordtmpv = cumsum(ordtmpv);
                dropidx = min([find(cumsum_ordtmpv >= cumsum_ordtmpv(end)*droptol,1) ...
                    find(ordtmpv >= droptol_max,1)])-1;
                if dropidx > 0
                    tmpv(ordix(1:dropidx)) = 0;
                end
                %M(p(nzidx),p(dd-1+jj)) = tmpv;
                M(nzidx,dd-2+jj) = tmpv;
            else
                % absolute drop tolerance means to simply drop all nonzero
                % elements smaller than droptol
                filter = min([droptol droptol_max]);
                %M(p(nzidx),p(dd-1+jj)) = tmpv.*(abs(tmpv) >= filter);
                M(nzidx,dd-1+jj) = tmpv.*(abs(tmpv) >= filter);
            end
        end
    end
    
 
    D(pvt_idx,pvt_idx) = M(:,pvt_idx)'*(A*M(:,pvt_idx));
    if s == 1 && abs(D(dd,dd)) < 64*sqrt(eps)*normA%) || (s == 2 && cond(full(D(dd:dd+1,dd:dd+1)))>1e16)
        D(dd,dd) = sign(0.5+sign(real(D(dd,dd))))*1e-2*normA;
    elseif s == 2 && cond(full(D(dd:dd+1,dd:dd+1))) > 1/eps
        D(dd+1,dd+1) = -sign(0.5+sign(real(D(dd,dd))))*1e-2*normA;
        %disp('Step %d, singular block D appears.\n',dd);
    end
    invD(pvt_idx,pvt_idx) = D(pvt_idx,pvt_idx)\speye(s,s);
    if nnz(isnan(D(dd:dd-1+s,dd:dd-1+s)))>0 || nnz(isinf(D(dd:dd-1+s,dd:dd-1+s))) > 0
        fprintf('What is wrong with D?\n');
    end
    svdPvt = svd(full(D(dd:dd-1+s,dd:dd-1+s)));
    if min(svdPvt) < small_sv_D,    small_sv_D = min(svdPvt);   end
    if max(svdPvt) > large_sv_D,    large_sv_D = max(svdPvt);   end
    condD = large_sv_D/small_sv_D;

    dd = dd + s;
%     if nnz(isnan(M)) > 0
%         fprintf('What is wrong with M?\n');
%     end
    tens_percent_done = floor(dd/n*10);
    if tens_percent_done > 0 && tens_percent_done < 10 && progress(tens_percent_done) == 0
        progress(tens_percent_done) = 1;
        nnzM = nnz(M);
        %D = spdiags([DSubd DMain [0; conj(DSubd(1:end-1))]],-1:1,n,n);
        %R = M(:,p(1:dd-1))'*A*M(:,p(1:dd-1))-D(1:(dd-1),1:(dd-1));
        R = M(:,1:dd-1)'*A*M(:,1:dd-1)-D(1:dd-1,1:dd-1);
        fprintf(' %d0%%: nnz(M) = %d (%.3f x nnz(A)), r-res = %.2d, cond(Dk) = %.2d, pvt type = [%d %d %d], norm(M) = %.2d.\n',...
            tens_percent_done,nnzM,nnzM/nnz(A),norm(R,'fro')/normAFro, condD,[pvttypesum(1) pvttypesum(2) pvttypesum(3)],norm(M,1));
    end
%     if tens_percent_done >= 5
%         fprintf('Step %d, nnz(M) = %d, norm(M) = %.3d, cond(D) = %.3d.\n',dd,nnz(M),norm(M,'fro'),condD);
%     end
end
nnzM = nnz(M);
% if nnz(sort(p)-(1:n)) > 0
%     error('Wrong permutation vector p\n');
% end
%D = spdiags([DSubd DMain [0; conj(DSubd(1:end-1))]],-1:1,n,n);
R = M'*A*M-D;
fprintf('100%%: nnz(M) = %d (%.3f x nnz(A)), r-res = %.2d, cond(Dk) = %.2d, pvt type = [%d %d %d], norm(M) = %.2d\n',...
    nnzM,nnzM/nnz(A),norm(R,'fro')/normAFro,condD,[pvttypesum(1) pvttypesum(2) pvttypesum(3)],norm(M,1));
fprintf('Drop tolerance = %d\n',droptol);
%M = M(p,p); % Unit upper triangular

end